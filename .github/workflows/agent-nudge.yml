name: Agent Nudge

on:
  schedule:
    - cron: '*/30 * * * *'
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
  workflow_dispatch: {}

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  nudge:
    runs-on: ubuntu-latest
    steps:
      - name: Ping Copilot on idle/conflicting RFC PRs
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;
            const now = new Date();
            const IDLE_MINS = 90; // default idle threshold for schedule

            // If invoked on a pull_request event, only process that PR for immediacy
            let prs = [];
            if (context.eventName === 'pull_request') {
              const pr = context.payload.pull_request;
              if (pr) prs = [pr];
            } else {
              prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', per_page: 100 });
            }

            for (const pr of prs) {
              const text = (pr.title || '') + '\n' + (pr.body || '');
              const hasRfc = /(RFC[- ]\d{4})/i.test(text);
              if (!hasRfc) continue;
              const isCopilotAuthor = /copilot/i.test(pr.user?.login || '');
              const isCopilotBranch = /copilot\//i.test(pr.head?.ref || '');
              const assignees = (pr.assignees || []).map(a => (a.login||'').toLowerCase());
              const isCopilotAssigned = assignees.includes('copilot');
              if (!(isCopilotAuthor || isCopilotBranch || isCopilotAssigned)) continue;

              // Skip very large PRs; PR Guard will handle guidance
              if ((pr.additions || 0) > 1200 || (pr.changed_files || 0) > 50) continue;

              // Fetch mergeability to tailor the message
              let mergeableState = null;
              try {
                const { data: fullPr } = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
                mergeableState = fullPr.mergeable_state; // clean, dirty, behind, unstable, etc.
              } catch {}

              // Avoid spam: only nudge if no prior nudge within window
              const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: pr.number, per_page: 100 });
              const recentHours = /dirty|behind/i.test(String(mergeableState||'')) ? 0.5 : 6; // allow more frequent nudges for conflicts
              const recentNudge = comments.find(c => c.body?.includes('<!-- nudge:copilot -->') && ((now - new Date(c.created_at)) / 3600000) < recentHours);
              if (recentNudge) continue;

              // Idle gating unless conflicting/behind
              if (!/dirty|behind/i.test(String(mergeableState||''))) {
                const updated = new Date(pr.updated_at);
                const idleMins = Math.round((now - updated)/60000);
                if (idleMins < IDLE_MINS && context.eventName !== 'pull_request') continue;
              }

              const lines = [
                '<!-- nudge:copilot -->',
                'Copilot, please continue this RFC PR in small batches per .github/copilot-instructions.md:',
                '- Keep changes within RFC scope; 3â€“5 files, < ~300 LOC.',
                '- If draft is ready and CI is green, mark Ready for review.',
                '- If blocked, reply here with the blocker and a proposed small next step.'
              ];
              if (/dirty|behind/i.test(String(mergeableState||''))) {
                lines.push('', 'This PR is out-of-date or has conflicts. Please rebase on main and push using a tokenized remote:',
                  'git fetch origin',
                  'git rebase origin/main',
                  'git add -A && git rebase --continue',
                  'git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/GiantCroissant-Lunar/falling-block-coding-agent.git"',
                  'git push --force-with-lease');
                try { await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ['needs-rebase','in-progress'] }); } catch {}
              } else {
                try { await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ['in-progress'] }); } catch {}
              }
              await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body: lines.join('\n') });
            }