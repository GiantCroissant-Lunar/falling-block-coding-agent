name: Agent Nudge

on:
  schedule:
    - cron: '*/4 * * * *'
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
  workflow_dispatch:
    inputs:
      idleMins:
        description: 'Idle minutes threshold before nudging'
        required: false
        default: '4'
      maxFiles:
        description: 'Skip nudges if changed files exceed this'
        required: false
        default: '50'

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  nudge:
    runs-on: ubuntu-latest
    steps:
      - name: Ping Copilot on idle PRs
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner, repo = context.repo.repo;
            // If invoked by a pull_request event, only process that PR for immediacy
            let prs = [];
            if (context.eventName === 'pull_request') {
              const pr = context.payload.pull_request;
              if (pr) prs = [pr];
            } else {
              prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', per_page: 100 });
            }
            const now = new Date();
            const inputIdle = (context.payload?.inputs?.idleMins || '').trim();
            const envIdle = (process.env.IDLE_MINS || '').trim();
            const IDLE_MINS = Number(inputIdle || envIdle || 4);
            const MAX_FILES = Number((context.payload?.inputs?.maxFiles || '').trim() || 50);
            for (const pr of prs) {
              const text = (pr.title || '') + '\n' + (pr.body || '');
              // No RFC/Copilot gating — nudge any open PR that appears idle

              // Skip very large PRs; PR Guard will handle guidance
              if ((pr.additions || 0) > 1200 || (pr.changed_files || 0) > MAX_FILES) continue;

              // Avoid spam: only nudge if no prior nudge within 6 hours
              const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: pr.number, per_page: 100 });
              const recentNudge = comments.find(c => c.body?.includes('<!-- nudge:copilot -->') && ((now - new Date(c.created_at)) / 3600000) < 6);
              if (recentNudge) continue;

              // Fetch mergeability to tailor the message
              let mergeableState = null;
              try {
                const { data: fullPr } = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
                mergeableState = fullPr.mergeable_state; // e.g., 'clean', 'dirty', 'behind'
              } catch {}

              // If PR is behind or has conflicts, bypass idle gating and nudge immediately
              if (!/dirty|behind/i.test(String(mergeableState || ''))) {
                const updated = new Date(pr.updated_at);
                const idleMins = Math.round((now - updated)/60000);
                if (idleMins < IDLE_MINS) continue;
              }

              const lines = [
                '<!-- nudge:copilot -->',
                'Copilot, please continue this PR in small batches per AGENTS.md:',
                '- Keep changes within the RFC scope; 3–5 files, < ~300 LOC.',
                '- If draft is ready and CI is green, mark Ready for review.',
                '- If blocked, reply here with the blocker and a proposed small next step.',
                'Stay on the current branch and push using a tokenized remote if needed.'
              ];
              if (mergeableState && /dirty|behind/i.test(String(mergeableState))) {
                lines.push('', 'Note: This PR is out-of-date or conflicting. Please fetch, rebase on main, resolve conflicts, rerun build/tests, and push using a tokenized remote.');
                lines.push('', 'Tokenized remote example:',
                  'https://x-access-token:${GITHUB_TOKEN}@github.com/GiantCroissant-Lunar/falling-block-coding-agent.git');
                try { await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ['needs-rebase'] }); } catch {}
              }
              await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body: lines.join('\n') });
              try { await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ['in-progress'] }); } catch {}
            }